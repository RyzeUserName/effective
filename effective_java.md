# 1. 对象创建

- 1.静态的工程方法代替对象的构造函数

  ​	优势：

  ​			１方法有名称 可以望文生义

  ​			２不必每次返回都创建一个新对象（基于自己的实现）

  ​			３可以返回 子对象实例	（Collections不可变集合的实例）

  ​			４可以根据参数的不同返回不同的实现类（隐蔽实现）EnumSet

  ​			５返回的对象可以在调用时在创建（懒加载、服务实现、JDBC、serviceLoader）

  ​	劣势：

  ​			１类不提供公有/保护的构造器，不能被子类化（其实子类也创建不了 编译不通过）

  ​			 2 很难发现

- 2.当一个类有很多构造参数的时候

  ​			1.构造器  参数多会混乱

  ​			2.javaBean 线程不安全

  ​			3.builder 模式	参数少时比较费劲

- 3.单例的用私有的构造函数或者是枚举

  ​		1.私有构造 + 公有成员 new 对象 

  ​		2.私有构造 + 私有成员 new 对象 + 公有的方法返回

  ​		3.枚举（单元素的枚举）

  ​		4.私有构造+公有的方法返回（方法锁）

  ​		5.私有构造+公有的方法返回（双重代码块锁）

- 4.非实例的类构造函数定为私有

  ​	工具类类似的类 Math  Arrays Collections

  ​	将这类工具类做抽象类是行不通的，子类可以实例化，而且 误导用户，

- 5.最好依赖注入而不是硬编码

  ​	不要用静态工具或者单例实现依赖一个或者多个底层资源的类，且该资源的行为会影响到该类的行为

- 6.避免创建不必要的对象

  ​	字符串的使用

  ​	优先使用基本类型而不是装箱类型

  ​	对象池的维护（连接池等）

- 7.消除过时的对象

  ​	1严重时 导致内存泄漏（数组不用的对象置为null）	

  ​	2内存泄漏的另一个常见来源是缓存（不常使用的项，应整理清除掉）

  ​	3内存泄漏的第三个常见是监听器和其他回调（可以使用弱引用）

- 8.finalizer和cleaner方法尽量不用，用的话也是做安全网

  ​	1finalizer 方法 不可预测，一般没必要 ，java9中的cleaner代替 但是依旧不可预测 运行缓慢...

  ​	2 让类自己实现AutoClosbale

   3. 对象的本地对等体

      ![1565598517370](.\assets\1565598517370.png)

      

- 9.try(resouce){} 代替try{}finally{}

# 2.所有类都有的方法

10. 覆盖equals请遵守通用约定

    自反性

    对称性

    传递性 （继承 会存在问题  getClass  instance 注意使用 ）

    一致性 （不要使用不可靠的资源equals URL的 equals）

    非空性  (非null对象 调用 equals 返回false)

11. 覆盖equals总要覆盖hashCode  

    否则基于hashCode 散列的集合出现错误

    1.hashCode 在一个应用中始终返回相同的值

    2.equals相等 hashcode 也应该相等

    3.equals不相等，hashcode 可以相等（但应该去提高散列表的性能）

    31*hash(a)+hash(b)

12. 始终覆盖toString

    

13. 慎重覆盖clone

    Cloneable 接口的目的是作为对象的一个mixin接口，表明这样的对象允许克隆，决定了Object中

    clone方法的实现行为，应覆盖clone() 方法

​       对象拷贝更好的办法是提供提个拷贝构造器或者拷贝工厂

​		![1565667171279](.\assets\1565667171279.png)

10. 考虑实现Comparable

# 3.类和 接口

11. 使类和成员的可访问性最小化

    解耦

12. 在公有类而非公有域中使用访问方法

13. 使可变性最小化

14. 复合优于继承

15. 要么继承提供文档 要么禁止继承

16. 接口优于抽象类

17. 为后代设计接口

18. 接口只用于定义类型

19. 类层次优于标签类

20. 静态成员类优于非静态成员类

21. 限制源文件为单个顶级类